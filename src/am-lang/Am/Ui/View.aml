
namespace Am.Ui 
{

    class View {
        import Am.Lang
        private var viewContext: ViewContext
        var x: Short
        var y: Short
        var width: UShort
        var height: UShort
        var padding: Insets = new Insets(0S, 0S, 0S, 0S)
        var growX: UByte
        var growY: UByte
        private var repaintRequested: Bool = false

        fun getRepaintRequested(): Bool {
            return this.repaintRequested
        }

        fun minWidth(): Short {
            return 0S
        }

        fun minHeight(): Short {
            return 0S
        }

/*
        fun growX(): UByte {
            return 0UB
        }

        fun growY(): UByte {
            return 0UB
        }
*/

        fun innerX(): Short {
            return this.x + this.padding.left
//            return this.padding.left
        }

        fun innerY(): Short {
            return this.y + this.padding.top
//            return this.padding.top
        }

        fun innerWidth(): Short {
            return (this.width.toShort() - (this.padding.left + this.padding.right))
        }

        fun innerHeight(): Short {
            return this.height.toShort() - (this.padding.top + this.padding.bottom)
        }

        fun setPadding(padding: Short) {
            this.padding.left = padding
            this.padding.top = padding
            this.padding.right = padding
            this.padding.bottom = padding
        }

        fun setPadding(horizontal: Short, vertical: Short) {
            this.padding.left = horizontal
            this.padding.top = vertical
            this.padding.right = horizontal
            this.padding.bottom = vertical
        }

        fun getViewContext(): ViewContext {
            return this.viewContext
        }

        fun getWindow(): Window {
            return this.viewContext.getWindow()
        }

        fun onAttach(viewContext: ViewContext) {
            if (this.viewContext != null) {
                throw new Exception("View already attached")
            }
            this.viewContext = viewContext
        }

        fun onDetach() {
            this.viewContext = null
        }

        fun paint(graphics: Graphics) {

        }

        fun paintAll(graphics: Graphics) {
            var b1 = graphics.shouldRepaintAll()
            var b2 = this.getRepaintRequested()
            if (b1 || b2) {
                var ix = this.innerX()
                var iy = this.innerY()
                graphics.translate(ix, iy)
                this.paint(graphics)
                this.markAsPainted()
                graphics.translate(-ix, -iy)
            }
        }

        fun markAsPainted() {
            this.repaintRequested = false
        }

        fun requestRepaint() {
            var b = this.repaintRequested
            if (!b) {
                this.repaintRequested = true
                this.viewContext.getWindow().requestRepaint()
            }
        }

        fun layout(x: Short, y: Short, width: UShort, height: UShort) {
            this.x = x
            this.y = y
            this.width = width
            this.height = height
//            ("Layout xyz" + x.toString() + "," + y.toString() + "," + width.toString() + "," + height.toString()).println()
        }

        fun contains(x: Short, y: Short): Bool {
            ("contains " + x.toString() + "," + y.toString() + " in " + this.width.toString() + ", " + this.height.toString()).println()

            return ((x >= 0S) && (x < this.width) && (y >= 0S) && (y < this.height))
        }

        fun findViewAt(x: Short, y: Short): View {
            if (this.contains(x, y)) {
                return this
            }
            return null
        }

        // returns true if consumed
        fun onMouseEvent(type: MouseEventType, button: MouseButton, x: Short, y: Short): Bool {
            if (this.contains(x, y)) {
                return true
            }
            return false
        }

        fun setup(i: (it: View) => View) : View {
            i(this)
            return this
        }

    }



}

