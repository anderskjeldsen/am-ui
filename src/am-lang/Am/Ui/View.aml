
namespace Am.Ui 
{
    class Graphics {
        import Am.Lang
        private var xOffset: Short
        private var yOffset: Short
//        var font: Font

        fun translate(x: Short, y: Short) {
            this.xOffset = this.xOffset + x
            this.yOffset = this.yOffset + y
        }

        abstract fun setForegroundPen(pen: UByte)
        abstract fun setBackgroundPen(pen: UByte)
        abstract fun drawLine(x: Short, y: Short, x2: Short, y2: Short)
        abstract fun fillRect(x: Short, y: Short, x2: Short, y2: Short)
        abstract fun eraseRect(x: Short, y: Short, x2: Short, y2: Short)
        abstract fun drawString(text: String, x: Short, y: Short)
        abstract fun calculateStringWidth(text: String): Short
        abstract fun getCurrentFontSize(): UByte
        abstract fun setFont(font: Font)
    }

    interface ViewContext {
        fun getWindow(): Window

        // Keep information about Window/Screen/Gadget Context etc.
    }

    native class ViewContextGraphics(var viewContext: ViewContext) : Graphics {
        import Am.Lang
        private fun getWindow(): Window {
            return this.viewContext.getWindow()
        }
        native override fun setForegroundPen(pen: UByte)
        native override fun setBackgroundPen(pen: UByte)
        native override fun drawLine(x: Short, y: Short, x2: Short, y2: Short)
        native override fun eraseRect(x: Short, y: Short, x2: Short, y2: Short)
        native override fun fillRect(x: Short, y: Short, x2: Short, y2: Short)
        native override fun drawString(text: String, x: Short, y: Short)
        native override fun calculateStringWidth(text: String): Short
        native override fun getCurrentFontSize(): UByte
        native override fun setFont(font: Font)

    }


    class ViewContextImpl : ViewContext {
        import Am.Lang

        private var windowRef: Weak<Window> = new Weak<Window>()
//        private var graphicsRef: Weak<ViewContextGraphics> = new Weak<ViewContextGraphics>()

        fun getWindow(): Window {
            return this.windowRef.get()
        }

        fun setWindow(window: Window) {
            this.windowRef.set(window)
        }
        
        /*
        fun getGraphics(): ViewContextGraphics {
            return this.graphicsRef.get()
        }

        fun setGraphics(graphics: ViewContextGraphics) {
            this.graphicsRef.set(graphics)
        }
        */


    }

    class View {
        import Am.Lang
        private var viewContext: ViewContext
        var x: Short
        var y: Short
        var width: UShort
        var height: UShort
        var padding: Padding = new Padding(0S, 0S, 0S, 0S)
        var growX: UByte
        var growY: UByte

        fun minWidth(): Short {
            return 0S
        }

        fun minHeight(): Short {
            return 0S
        }

/*
        fun growX(): UByte {
            return 0UB
        }

        fun growY(): UByte {
            return 0UB
        }
*/

        fun innerX(): Short {
            return this.x + this.padding.left
        }

        fun innerY(): Short {
            return this.y + this.padding.top
        }

        fun innerWidth(): Short {
            return (this.width.toShort() - (this.padding.left + this.padding.right))
        }

        fun innerHeight(): Short {
            return this.height.toShort() - (this.padding.top + this.padding.bottom)
        }

        fun setPadding(padding: Short) {
            this.padding.left = padding
            this.padding.top = padding
            this.padding.right = padding
            this.padding.bottom = padding
        }

        fun setPadding(horizontal: Short, vertical: Short) {
            this.padding.left = horizontal
            this.padding.top = vertical
            this.padding.right = horizontal
            this.padding.bottom = vertical
        }

        fun getViewContext(): ViewContext {
            return this.viewContext
        }

        fun getWindow(): Window {
            return this.viewContext.getWindow()
        }

        fun onAttach(viewContext: ViewContext) {
            if (this.viewContext != null) {
                throw new Exception("View already attached")
            }
            this.viewContext = viewContext
        }

        fun onDetach() {
            this.viewContext = null
        }

        fun paint(graphics: Graphics) {

        }

        fun paintAll(graphics: Graphics) {
            var ix = this.innerX()
            var iy = this.innerY()
            ("Inner pos " + ix.toString()).println()
            graphics.translate(ix, iy)
            this.paint(graphics)
            graphics.translate(-ix, -iy)
        }

        fun layout(x: Short, y: Short, width: UShort, height: UShort) {
            this.x = x
            this.y = y
            this.width = width
            this.height = height
            ("Layout " + x.toString() + "," + y.toString() + "," + width.toString() + "," + height.toString()).println()
        }

        fun contains(x: Short, y: Short): Bool {
            ("contains " + x.toString() + "," + y.toString() + " in " + this.width.toString() + ", " + this.height.toString()).println()
/*
            var xok1 = (x >= 0S)
            var xok2 = (x < this.width.toShort())
            return xok1 && xok2
            var xok2 = (x < this.width.toShort())
            var xok = ((x >= 0S) && (x < this.width.toShort()))
            var yok = ((y >= 0S) && (y < this.height.toShort()))
            ("xok: " + xok.toString() + ", yok: " + yok.toString()).println()
            return xok && yok
            */
            return ((x >= 0S) && (x < this.width) && (y >= 0S) && (y < this.height))
        }

        fun findViewAt(x: Short, y: Short): View {
            if (this.contains(x, y)) {
                return this
            }
            return null
        }

        // returns true if consumed
        fun onMouseClick(button: UByte, x: Short, y: Short): Bool {
//            ("View click: " + button.toString() + " " + x.toString() + " " + y.toString()).println()

            if (this.contains(x, y)) {
                return true
            }
            return false
        }

        fun setup(i: (it: View) => View) : View {
            i(this)
            return this
        }

    }

    class ViewGroup : View {
        import Am.Lang
        import Am.Collections

        private var children: List<View> = List<View>.newList<View>()
        
        var font: Font

        fun getChildren() {
            return this.children
        }

        fun addChild(view: View) {
            this.children.add(view)
            if (this.viewContext != null) {
                view.onAttach(this.viewContext)
            }
        }

        fun removeChild(view: View) {
            this.children.remove(view)
            view.onDetach()
        }

        override fun onAttach(viewContext: ViewContext) {
            base.onAttach(viewContext)
            "attach children".println()
            each(this.children, c) {
                "attach child".println()
                c.onAttach(viewContext)
            }
            "attach done".println()
        }

        override fun onDetach() {
            base.onDetach()
            each(this.children, c) {
                c.onDetach()
            }
        }


        fun paintChildren(graphics: Graphics) {
            each(this.children, c) {
                c.paintAll(graphics)
            }
        }

        override fun paintAll(graphics: Graphics) {
            var ix = this.innerX()
            var iy = this.innerY()
            ("inner x for viewgroup: " + ix.toString()).println()
            graphics.translate(ix, iy)
            this.paint(graphics)
            this.paintChildren(graphics)
            graphics.translate(-ix, -iy)
        }

        fun layoutChildren() {
            each(this.children, c) {
                // Do nothing
            }
        }

        override fun layout(x: Short, y: Short, width: UShort, height: UShort) {
            base.layout(x, y, width, height)
            this.layoutChildren()
        }

        override fun findViewAt(x: Short, y: Short): View {
            if (this.contains(x, y)) {
                each(this.children, c) {
                    var lx = x - c.x
                    var ly = y - c.y

                    var v = c.findViewAt(lx, ly)
                    if (v != null) {
                        return v
                    }
                }
                return this
            }
            return null
        }

        override fun onMouseClick(button: UByte, x: Short, y: Short): Bool {
            if (this.contains(x, y)) {
                each(this.children, c) {
                    var lx = x - c.x
                    var ly = y - c.y

                    var consumed = c.onMouseClick(button, lx, ly)
                    if (consumed) {
                        return consumed
                    }
                }
            }
            return false
        }


    }

    class VStack(var spacing: Short) : ViewGroup {
        import Am.Lang
        import Am.Collections

        override fun layoutChildren() {
            "layout childsen".println()
            var left = 0S
            var y = 0S
            "layout childsenA".println()
            var height = this.innerHeight()
            "layout childsenAA".println()
            var minHeight = this.innerMinHeight()
            "layout childsenB".println()

            var unusedHeight = height - minHeight
            var remainingHeight = unusedHeight
            "layout childsenC".println()

            var sumGrowY = this.sumGrowY()
                        "layout childsenD".println()

            var innerWidth = this.innerWidth() 
//            ("inner width VStack: " + innerWidth.toString() + " vs " + this.width.toString()).println()

            "layout childsen2".println()

            each(this.children, c) {
                var ch = c.minHeight() + ((c.growY.toInt() * unusedHeight.toInt()) / sumGrowY.toInt()).toShort()
                c.layout(left, y, innerWidth.toUShort(), ch.toUShort())
                y = y + ch + this.spacing
            }
                        "layout childsen3".println()

        }

        fun innerMinHeight(): Short {
            var h = 0S
            each(this.children, c) {
                if (h > 0S) {
                    h = h + this.spacing
                }
                h = h + c.minHeight()
            }
            return h
        }

        override fun minHeight(): Short {
            return this.innerMinHeight() + this.padding.top + this.padding.bottom
        }

        fun innerMinWidth(): Short {
            var minW = 0S
            each(this.children, c) {
                var cMinW = c.minWidth()
                if (cMinW > minW) {
                    minW = cMinW
                }
            }
            return minW
        }

        override fun minWidth(): Short {
            return this.innerMinWidth() + this.padding.left + this.padding.right
        }

        fun sumGrowY(): Short {
            var grow = 0S
            each(this.children, c) {
                grow = grow + c.growY.toShort()
            }
            if (grow == 0) {
                grow = 1S
            }
            return grow
        }

    }

    class HStack : ViewGroup {
        import Am.Lang
        import Am.Collections

        override fun layoutChildren() {
            var x = 0S
            var y = 0S
            var width = this.width
            var childWidth = width / this.children.size.toUShort()

            each(this.children, c) {
                c.layout(x, y, childWidth, this.height)
                x = x + childWidth.toShort()
            }
        }

    }

    native class Font(private var name: String, private var size: UByte) {
        import Am.Lang
        import Am.Collections

        private static var cache: HashMap<String, Font> // = new HashMap<String, Font>()

        fun getName(): String {
            return this.name
        }

        fun getSize(): UByte {
            return this.size
        }

        native fun calculateStringWidth(text: String)

        static fun loadFont(var name: String, var size: UByte) {
            var key = name + ":" + size.toString()
            var font = Font.cache.get(key)
            if (font == null) {
                font = new Font(name, size)
                Font.cache.set(key, font)
            }
            return font
        }
    }

    native class GadgetViews {
        import Am.Lang

        native static fun layoutNative(gadgetView: GadgetView, x: Short, y: Short, width: UShort, height: UShort)
    }

    class GadgetView : View {
        import Am.Lang

        override fun layout(x: Short, y: Short, width: UShort, height: UShort) {
            base.layout(x, y, width, height)
            GadgetViews.layoutNative(this, x, y, width, height)
        }
    }

    native class Button : GadgetView {
        import Am.Lang

        private native fun attachButton(window: Window)
        private native fun detachButton(window: Window)

        override fun onAttach(viewContext: ViewContext) {
            base.onAttach(viewContext)
            this.attachButton(viewContext.getWindow())
        }

        override fun onDetach() {
            this.detachButton(this.viewContext.getWindow())
            base.onDetach()
        }
    }

    class Label(var text: String) : View {
        import Am.Lang

        var font: Font

        fun getUsedFont(): Font {
            if (this.font != null) {
                return this.font
            }
            var vc = this.viewContext 
            if (vc != null) {
                return vc.getWindow().font
            }
            return null
        }

        override fun minHeight(): Short {
            var font = this.getUsedFont()
            if (font != null) {
                return font.size.toShort()
            }
            var vc = this.viewContext 
            if (vc != null) {
                "get font size".println()
                return vc.getWindow().getCurrentFontSize().toShort()
            }
            return 0S
        }

        override fun minWidth(): Short {
            "minwidth".println()
            var font = this.getUsedFont()
            return this.viewContext.getWindow().calculateStringWidth(font, this.text).toShort()
        }

        override fun paint(graphics: Graphics) {
            base.paint(graphics)

            var x1 = 0S
            var y1 = 0S

            graphics.setForegroundPen(1UB)
            var font = this.getUsedFont()
            if (font != null) {
                graphics.setFont(font)
            }

            graphics.drawString(this.text, x1, y1)
        }
    }

    class TestButton(var text: String, var clickListener: (view: View) => Bool) : View {
        import Am.Lang

        private var label: Label

        private fun ensureLabel(): Label {
            if (this.label == null) {
                this.label = new Label(this.text)
            }
            return this.label
        }

        override fun minHeight(): Short {
            var label = this.ensureLabel()
            return label.minHeight() + this.padding.top + this.padding.bottom
        }

        override fun minWidth(): Short {
            var label = this.ensureLabel()
            return label.minWidth() + this.padding.left + this.padding.right
        }

        override fun layout(x: Short, y: Short, width: UShort, height: UShort) {
            base.layout(x, y, width, height)
            var label = this.ensureLabel()
            label.layout(this.innerX(), this.innerY(), this.innerWidth().toUShort(), this.innerHeight().toUShort())            
        }

        override fun paint(graphics: Graphics) {
            base.paint(graphics)

            var x1 = 0S
            var x2 = this.innerWidth() - 1S
            var y1 = 0S
            var y2 = this.innerHeight() - 1S

            ("Paint " + x1.toString() + " to " + x2.toString()).println()

            graphics.setForegroundPen(3UB)
            graphics.fillRect(x1, y1, x2, y2)
            graphics.setForegroundPen(1UB)

            graphics.drawLine(x1, y1, x2, y1)
            graphics.drawLine(x2, y1, x2, y2)
            graphics.drawLine(x1, y2, x2, y2)
            graphics.drawLine(x1, y1, x1, y2)

            var label = this.ensureLabel()
            label.paint(graphics)
        }

        override fun onMouseClick(button: UByte, x: Short, y: Short): Bool {
            ("Button click: " + button.toString() + " " + x.toString() + " " + y.toString()).println()

            if (this.contains(x, y)) {
                ("Button clicked: " + this.text).println()
//                this.clickListener?(this)
                var cl = this.clickListener
                if (cl != null) {
                    var res = cl(this)                    
                    return res
                }
            }
            return false
        }



    }
}

