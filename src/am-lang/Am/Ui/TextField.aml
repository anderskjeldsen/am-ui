namespace Am.Ui 
{

    class TextField : View {
        import Am.Lang

        private var text: String = ""
        private var focused: Bool = false
        private var cursorPosition: Int = 0
        private var selectionStart: Int = 0
        private var selectionEnd: Int = 0
        var maxLength: Int = 255
        var placeholder: String = ""
        var readOnly: Bool = false
        var passwordMode: Bool = false
        
        var textPen: UByte = 1UB
        var backgroundPen: UByte = 0UB
        var focusedBackgroundPen: UByte = 0UB
        var placeholderPen: UByte = 2UB
        var selectionPen: UByte = 3UB
        var cursorPen: UByte = 1UB
        
        private var borderPens: BorderPens = new BorderPens(1UB, 1UB, 2UB, 2UB)
        private var focusedBorderPens: BorderPens = new BorderPens(2UB, 2UB, 1UB, 1UB)

        fun getText(): String {
            return this.text
        }

        fun setText(text: String) {
            if (text.length() > this.maxLength) {
                this.text = text.substring(0UI, this.maxLength.toUInt())
            } else {
                this.text = text
            }
            this.cursorPosition = this.text.length()
            this.clearSelection()
            this.requestRepaint()
        }

        fun setPlaceholder(placeholder: String) {
            this.placeholder = placeholder
            this.requestRepaint()
        }

        fun getPlaceholder(): String {
            return this.placeholder
        }

        fun setFocused(focused: Bool) {
            this.focused = focused
            this.requestRepaint()
        }

        fun isFocused(): Bool {
            return this.focused
        }

        fun setCursorPosition(position: Int) {
            if (position < 0) {
                this.cursorPosition = 0
            } else if (position > this.text.length()) {
                this.cursorPosition = this.text.length()
            } else {
                this.cursorPosition = position
            }
            this.requestRepaint()
        }

        fun getCursorPosition(): Int {
            return this.cursorPosition
        }

        private fun clearSelection() {
            this.selectionStart = this.cursorPosition
            this.selectionEnd = this.cursorPosition
        }

        private fun hasSelection(): Bool {
            return this.selectionStart != this.selectionEnd
        }

        fun selectAll() {
            this.selectionStart = 0
            this.selectionEnd = this.text.length()
            this.cursorPosition = this.selectionEnd
            this.requestRepaint()
        }

        private fun textUpdated() {

        }

        fun insertText(newText: String) {
            if (this.readOnly) {
                return
            }

            var insertPosition = this.cursorPosition
            
            if (this.hasSelection()) {
                // Replace selection
                var beforeSelection = this.text.substring(0UI, this.selectionStart.toUInt())
                var afterSelection = this.text.substring(this.selectionEnd.toUInt(), (this.text.length() - this.selectionEnd).toUInt())
                this.text = beforeSelection + newText + afterSelection
                insertPosition = this.selectionStart + newText.length()
            } else {
                // Insert at cursor
                var beforeCursor = this.text.substring(0UI, this.cursorPosition.toUInt())
                var afterCursor = this.text.substring(this.cursorPosition.toUInt(), (this.text.length() - this.cursorPosition).toUInt())
                this.text = beforeCursor + newText + afterCursor
                insertPosition = this.cursorPosition + newText.length()
            }

            // Trim to max length
            if (this.text.length() > this.maxLength) {
                this.text = this.text.substring(0UI, this.maxLength.toUInt())
                if (insertPosition > this.maxLength) {
                    insertPosition = this.maxLength
                }
            }

            this.setCursorPosition(insertPosition)
            this.clearSelection()
        }

        fun deleteBackward() {
            if (this.readOnly) {
                return
            }

            if (this.hasSelection()) {
                this.insertText("")
            } else if (this.cursorPosition > 0) {
                var beforeCursor = this.text.substring(0UI, (this.cursorPosition - 1).toUInt())
                var afterCursor = this.text.substring(this.cursorPosition.toUInt(), (this.text.length() - this.cursorPosition).toUInt())
                this.text = beforeCursor + afterCursor
                this.setCursorPosition(this.cursorPosition - 1)
            }
        }

        fun deleteForward() {
            if (this.readOnly) {
                return
            }

            if (this.hasSelection()) {
                this.insertText("")
            } else if (this.cursorPosition < this.text.length()) {
                var beforeCursor = this.text.substring(0UI, this.cursorPosition.toUInt())
                var afterCursor = this.text.substring((this.cursorPosition + 1).toUInt(), (this.text.length() - this.cursorPosition - 1).toUInt())
                this.text = beforeCursor + afterCursor
                this.requestRepaint()
            }
        }

        override fun setDefaultPadding() {
            this.setPadding(4S, 2S)
        }

        override fun setDefaultBorder() {
            this.setBorderWidths(1S)
        }

        override fun minHeight(): Short {
            var vc = this.getViewContext()
            var fontHeight: Short = 0S
            if (vc != null) {
                fontHeight = vc.getWindow().getCurrentFontSize().toShort()
            } else {
                fontHeight = 12S
            }
            return fontHeight + 4S + base.minHeight()
        }

        override fun minWidth(): Short {
            return 100S + base.minWidth()
        }

        override fun paint(graphics: Graphics) {
            base.paint(graphics)

            var innerW = this.innerWidth()
            var innerH = this.innerHeight()
            var x1 = 0S
            var y1 = 0S
            var x2 = this.width.toShort() - (this.margin.right + this.margin.left + 1S)
            var y2 = this.height.toShort() - (this.margin.bottom + this.margin.top + 1S)

            // Draw background
            var bgPen: UByte = 0UB
            if (this.focused) {
                bgPen = this.focusedBackgroundPen
            } else {
                bgPen = this.backgroundPen
            }
            graphics.setForegroundPen(bgPen)
            graphics.fillRect(x1, y1, x2, y2)

            // Draw border
            var borderPens: BorderPens
            if (this.focused) {
                borderPens = this.focusedBorderPens
            } else {
                borderPens = this.borderPens
            }
            this.paintNativeBorder(graphics, borderPens)

            // Calculate text area
            var textX = this.borderWidths.left + this.padding.left
            var textY = this.borderWidths.top + this.padding.top
            var textWidth = innerW - this.padding.left - this.padding.right
            var textHeight = innerH - this.padding.top - this.padding.bottom

            // Set clipping area for text
//            graphics.setClipArea(textX, textY, textWidth.toUShort(), textHeight.toUShort())

            // Draw text or placeholder
            var displayText = this.text
            if (displayText.length() == 0 && !this.placeholder.length() == 0 && !this.focused) {
                graphics.setForegroundPen(this.placeholderPen)
                graphics.drawString(this.placeholder, textX, textY)
            } else {
                if (this.passwordMode) {
                    var stars = ""
                    var i = 0
                    while (i < displayText.length()) {
                        stars = stars + "*"
                        i = i + 1
                    }
                    displayText = stars
                }
                
                // Draw text with cursor if focused
                if (this.focused && this.cursorPosition <= displayText.length()) {
                    // Draw text before cursor
                    if (this.cursorPosition > 0) {
                        var beforeCursor = displayText.substring(0UI, this.cursorPosition.toUInt())
                        graphics.setForegroundPen(this.textPen)
                        graphics.drawString(beforeCursor, textX, textY)
                    }
                    
                    // Calculate cursor X position
                    var cursorX = textX
                    if (this.cursorPosition > 0) {
                        var beforeCursor = displayText.substring(0UI, this.cursorPosition.toUInt())
                        cursorX = cursorX + graphics.calculateStringWidth(beforeCursor).toShort()
                    }
                    
                    // Draw cursor character with background rectangle
                    if (this.cursorPosition < displayText.length()) {
                        // Get character at cursor position
                        var cursorChar = displayText.substring(this.cursorPosition.toUInt(), 1UI)
                        
                        // Calculate character width
                        var charWidth = graphics.calculateStringWidth(cursorChar).toShort()
                        var fontHeight = graphics.getCurrentFontSize().toShort()
                        
                        // Fill cursor background rectangle
                        graphics.setForegroundPen(this.textPen)
                        graphics.fillRect(cursorX, textY, cursorX + charWidth - 1S, textY + fontHeight - 1S)
                        
                        // Draw character in cursor background color (assuming 0 is white/background)
                        graphics.setForegroundPen(this.backgroundPen)
                        graphics.drawString(cursorChar, cursorX, textY)
                        
                        // Draw text after cursor
                        if (this.cursorPosition + 1 < displayText.length()) {
                            var afterCursor = displayText.substring((this.cursorPosition + 1).toUInt(), (displayText.length() - this.cursorPosition - 1).toUInt())
                            graphics.setForegroundPen(this.textPen)
                            graphics.drawString(afterCursor, cursorX + charWidth, textY)
                        }
                    } else {
                        // Cursor is at end of text - draw cursor using width of "X"
                        var fontHeight = graphics.getCurrentFontSize().toShort()
                        var cursorWidth = graphics.calculateStringWidth("X").toShort()
                        graphics.setForegroundPen(this.cursorPen)
                        graphics.fillRect(cursorX, textY, cursorX + cursorWidth - 1S, textY + fontHeight - 1S)
                    }
                } else {
                    // Not focused - draw text normally
                    graphics.setForegroundPen(this.textPen)
                    graphics.drawString(displayText, textX, textY)
                }

                // Draw selection if focused and has selection
                if (this.focused && this.hasSelection()) {
                    // TODO: Calculate selection rectangle and draw it
                    // This would require character-by-character width calculation
                }
            }

//            graphics.resetClipArea()
        }

        override fun onMouseEvent(type: MouseEventType, button: MouseButton, x: Short, y: Short): Bool {
            if (this.contains(x, y)) {
                if (type == MouseEventType.down && button == MouseButton.left) {
                    this.setFocused(true)
                    // TODO: Calculate cursor position from x coordinate
                    // This would require character-by-character width calculation
                    return true
                }
            } else {
                if (type == MouseEventType.down) {
                    this.setFocused(false)
                }
            }
            return false
        }

        override fun onKeyboardEvent(type: KeyboardEventType, keyCode: UShort, keyChar: UShort): Bool {
            if (!this.focused || this.readOnly) {
                return false
            }



            if (type == KeyboardEventType.down) {
                // Handle arrow keys and navigation first (using keyCode)
                if (keyCode == 76US) { // Left arrow (AmigaOS raw key)
                    this.setCursorPosition(this.cursorPosition - 1)
                    this.clearSelection()
                    return true
                } else if (keyCode == 77US) { // Right arrow (AmigaOS raw key)
                    this.setCursorPosition(this.cursorPosition + 1)
                    this.clearSelection()
                    return true
                } else if (keyCode == 74US) { // Up arrow (could be used for Home)
                    this.setCursorPosition(0)
                    this.clearSelection()
                    return true
                } else if (keyCode == 75US) { // Down arrow (could be used for End)
                    this.setCursorPosition(this.text.length())
                    this.clearSelection()
                    return true
                }
                
                // Handle special character keys using keyChar
                if (keyChar == 8US) { // Backspace (ASCII)
                    this.deleteBackward()
                    return true
                } else if (keyChar == 127US) { // Delete (ASCII)
                    this.deleteForward()
                    return true
                } else if (keyChar == 9US) { // Tab
                    // Could handle tab here if needed
                    return false
                } else if (keyChar == 13US || keyChar == 10US) { // Return/Enter
                    // Could handle enter here if needed
                    return false
                } else if (keyChar >= 32US && keyChar <= 126US) { // Printable ASCII from keyChar
                    // Convert keyChar to string and use existing insertText method
                    var sb = new StringBuilder()
                    sb.addChar(keyChar)
                    var charString = sb.toString()
                    
                    this.insertText(charString)
                    return true
                }
                
                // Also check if keyChar has control character values for special keys
                if (keyChar == 37US) { // Left arrow (if passed as ASCII)
                    this.setCursorPosition(this.cursorPosition - 1)
                    this.clearSelection()
                    return true
                } else if (keyChar == 39US) { // Right arrow (if passed as ASCII)
                    this.setCursorPosition(this.cursorPosition + 1)
                    this.clearSelection()
                    return true
                } else if (keyChar == 36US) { // Home (if passed as ASCII)
                    this.setCursorPosition(0)
                    this.clearSelection()
                    return true
                } else if (keyChar == 35US) { // End (if passed as ASCII)
                    this.setCursorPosition(this.text.length())
                    this.clearSelection()
                    return true
                }
            }
            return false
        }
    }
}