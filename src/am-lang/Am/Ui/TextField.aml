namespace Am.Ui 
{

    class TextField : View {
        import Am.Lang

        private var text: String = ""
        private var focused: Bool = false
        private var cursorPosition: Int = 0
        private var selectionStart: Int = 0
        private var selectionEnd: Int = 0
        var maxLength: Int = 255
        var placeholder: String = ""
        var readOnly: Bool = false
        var passwordMode: Bool = false
        
        var textPen: UByte = 1UB
        var backgroundPen: UByte = 0UB
        var focusedBackgroundPen: UByte = 0UB
        var placeholderPen: UByte = 2UB
        var selectionPen: UByte = 3UB
        var cursorPen: UByte = 3UB
        
        // Outer border: 2UB on left and upper, 1UB on lower and right
        private var outerBorderPens: BorderPens = new BorderPens(2UB, 2UB, 1UB, 1UB)
        private var focusedOuterBorderPens: BorderPens = new BorderPens(2UB, 2UB, 1UB, 1UB)
        
        // Inner border: 1UB on upper and left, 2UB on lower and right  
        private var innerBorderPens: BorderPens = new BorderPens(1UB, 1UB, 2UB, 2UB)
        private var focusedInnerBorderPens: BorderPens = new BorderPens(1UB, 1UB, 2UB, 2UB)

        fun getText(): String {
            return this.text
        }

        fun setText(text: String) {
            if (text.length() > this.maxLength) {
                this.text = text.substring(0UI, this.maxLength.toUInt())
            } else {
                this.text = text
            }
            this.cursorPosition = this.text.length()
            this.clearSelection()
            this.requestRepaint()
        }

        fun setPlaceholder(placeholder: String) {
            this.placeholder = placeholder
            this.requestRepaint()
        }

        fun getPlaceholder(): String {
            return this.placeholder
        }

        fun setFocused(focused: Bool) {
            this.focused = focused
            this.requestRepaint()
        }

        fun isFocused(): Bool {
            return this.focused
        }

        fun setCursorPosition(position: Int) {
            if (position < 0) {
                this.cursorPosition = 0
            } else if (position > this.text.length()) {
                this.cursorPosition = this.text.length()
            } else {
                this.cursorPosition = position
            }
            this.requestRepaint()
        }

        fun getCursorPosition(): Int {
            return this.cursorPosition
        }

        private fun clearSelection() {
            this.selectionStart = this.cursorPosition
            this.selectionEnd = this.cursorPosition
        }

        private fun hasSelection(): Bool {
            return this.selectionStart != this.selectionEnd
        }

        fun selectAll() {
            this.selectionStart = 0
            this.selectionEnd = this.text.length()
            this.cursorPosition = this.selectionEnd
            this.requestRepaint()
        }

        private fun textUpdated() {

        }

        fun insertText(newText: String) {
            if (this.readOnly) {
                return
            }

            var insertPosition = this.cursorPosition
            
            if (this.hasSelection()) {
                // Replace selection
                var beforeSelection = this.text.substring(0UI, this.selectionStart.toUInt())
                var afterSelection = this.text.substring(this.selectionEnd.toUInt(), (this.text.length() - this.selectionEnd).toUInt())
                this.text = beforeSelection + newText + afterSelection
                insertPosition = this.selectionStart + newText.length()
            } else {
                // Insert at cursor
                var beforeCursor = this.text.substring(0UI, this.cursorPosition.toUInt())
                var afterCursor = this.text.substring(this.cursorPosition.toUInt(), (this.text.length() - this.cursorPosition).toUInt())
                this.text = beforeCursor + newText + afterCursor
                insertPosition = this.cursorPosition + newText.length()
            }

            // Trim to max length
            if (this.text.length() > this.maxLength) {
                this.text = this.text.substring(0UI, this.maxLength.toUInt())
                if (insertPosition > this.maxLength) {
                    insertPosition = this.maxLength
                }
            }

            this.setCursorPosition(insertPosition)
            this.clearSelection()
        }

        fun deleteBackward() {
            if (this.readOnly) {
                return
            }

            if (this.hasSelection()) {
                this.insertText("")
            } else if (this.cursorPosition > 0) {
                var beforeCursor = this.text.substring(0UI, (this.cursorPosition - 1).toUInt())
                var afterCursor = this.text.substring(this.cursorPosition.toUInt(), (this.text.length() - this.cursorPosition).toUInt())
                this.text = beforeCursor + afterCursor
                this.setCursorPosition(this.cursorPosition - 1)
            }
        }

        fun deleteForward() {
            if (this.readOnly) {
                return
            }

            if (this.hasSelection()) {
                this.insertText("")
            } else if (this.cursorPosition < this.text.length()) {
                var beforeCursor = this.text.substring(0UI, this.cursorPosition.toUInt())
                var afterCursor = this.text.substring((this.cursorPosition + 1).toUInt(), (this.text.length() - this.cursorPosition - 1).toUInt())
                this.text = beforeCursor + afterCursor
                this.requestRepaint()
            }
        }

        override fun setDefaultPadding() {
            this.setPadding(4S, 2S)
        }

        override fun setDefaultBorder() {
            this.setBorderWidths(2S) // Static border width - scaling handled during drawing
        }

        override fun minHeight(): Short {
            var vc = this.getViewContext()
            var fontHeight: Short = 0S
            if (vc != null) {
                fontHeight = vc.getWindow().getCurrentFontSize().toShort()
                "font height $fontHeight".println()
            } else {
                "font height 12".println()
                fontHeight = 12S
            }
            return fontHeight + base.minHeight()
        }

        override fun minWidth(): Short {
            return 100S + base.minWidth()
        }

        override fun paint(graphics: Graphics) {
            base.paint(graphics)

            var innerW = this.innerWidth()
            var innerH = this.innerHeight()
            var x1 = 0S
            var y1 = 0S
            var x2 = this.width.toShort() - (this.margin.right + this.margin.left + 1S)
            var y2 = this.height.toShort() - (this.margin.bottom + this.margin.top + 1S)

            // Draw background
            var bgPen: UByte = 0UB
            if (this.focused) {
                bgPen = this.focusedBackgroundPen
            } else {
                bgPen = this.backgroundPen
            }
            graphics.setForegroundPen(this.backgroundPen)
            graphics.fillRect(x1, y1, x2, y2)

            // Draw outer border
            var outerBorderPens: BorderPens
            if (this.focused) {
                outerBorderPens = this.focusedOuterBorderPens
            } else {
                outerBorderPens = this.outerBorderPens
            }
            this.paintNativeBorder(graphics, outerBorderPens)
            
            // Draw inner border (1 pixel inside the outer border)
            var innerBorderPens: BorderPens
            if (this.focused) {
                innerBorderPens = this.focusedInnerBorderPens
            } else {
                innerBorderPens = this.innerBorderPens
            }
            
            // Calculate inner border position using scaled pixel metrics
            var window = this.getWindow()
            var borderOffsetX = window.getScaledX(1S)
            var borderOffsetY = window.getScaledY(1S)
            var innerX1 = x1 + borderOffsetX
            var innerY1 = y1 + borderOffsetY
            var innerX2 = x2 - borderOffsetX
            var innerY2 = y2 - borderOffsetY
            
            // Draw inner border lines manually, using pixel metrics for proper scaling
            var scaledLineWidthX = window.getScaledX(1S)
            var scaledLineWidthY = window.getScaledY(1S)
            
            // Top line (1UB)
            graphics.setForegroundPen(innerBorderPens.top)
            graphics.drawLine(innerX1, innerY1, innerX2, innerY1)
            
            // Left line (1UB) - use scaled width for proper aspect ratio
            graphics.setForegroundPen(innerBorderPens.left)
            for (i = 0 to scaledLineWidthY.toUInt()) {
                var si = i.toShort()
                graphics.drawLine(innerX1 + si, innerY1, innerX1 + si, innerY2)
            }
            
            // Bottom line (2UB)
            graphics.setForegroundPen(innerBorderPens.bottom)
            graphics.drawLine(innerX1, innerY2, innerX2, innerY2)
            
            // Right line (2UB) - use scaled width for proper aspect ratio
            graphics.setForegroundPen(innerBorderPens.right)
            for (i = 0 to scaledLineWidthX.toUInt()) {
                var si = i.toShort()
                graphics.drawLine(innerX2 - si, innerY1, innerX2 - si, innerY2)
            }

            // Calculate text area
            var textX = this.borderWidths.left + this.padding.left
            var textY = this.borderWidths.top + this.padding.top
            var textWidth = innerW - this.padding.left - this.padding.right
            var textHeight = innerH - this.padding.top - this.padding.bottom

            // Set clipping area for text
//            graphics.setClipArea(textX, textY, textWidth.toUShort(), textHeight.toUShort())

            // Draw text or placeholder
            var displayText = this.text
            if (displayText.length() == 0 && !this.placeholder.length() == 0 && !this.focused) {
                graphics.setForegroundPen(this.placeholderPen)
                graphics.drawString(this.placeholder, textX, textY)
            } else {
                if (this.passwordMode) {
                    var stars = ""
                    var i = 0
                    while (i < displayText.length()) {
                        stars = stars + "*"
                        i = i + 1
                    }
                    displayText = stars
                }
                
                // Draw text with cursor if focused
                if (this.focused && this.cursorPosition <= displayText.length()) {
                    // Draw text before cursor
                    if (this.cursorPosition > 0) {
                        var beforeCursor = displayText.substring(0UI, this.cursorPosition.toUInt())
                        graphics.setForegroundPen(this.textPen)
                        graphics.drawString(beforeCursor, textX, textY)
                    }
                    
                    // Calculate cursor X position
                    var cursorX = textX
                    if (this.cursorPosition > 0) {
                        var beforeCursor = displayText.substring(0UI, this.cursorPosition.toUInt())
                        cursorX = cursorX + graphics.calculateStringWidth(beforeCursor).toShort()
                    }
                    
                    // Draw cursor character with background rectangle
                    if (this.cursorPosition < displayText.length()) {
                        // Get character at cursor position
                        var cursorChar = displayText.substring(this.cursorPosition.toUInt(), 1UI)
                        
                        // Calculate character width
                        var charWidth = graphics.calculateStringWidth(cursorChar).toShort()
                        var fontHeight = graphics.getCurrentFontSize().toShort()
                        
                        // Draw character with cursor background and white text                        
                        // Fill extra lines above and below the text
                        graphics.setForegroundPen(this.cursorPen)
                        graphics.fillRect(cursorX, textY - 1S, cursorX + charWidth - 1S, textY - 1S) // Line above
                        graphics.fillRect(cursorX, textY + fontHeight, cursorX + charWidth - 1S, textY + fontHeight) // Line below
                        
                        // Set background pen to cursor color for drawString
                        graphics.setBackgroundPen(this.cursorPen)
                        graphics.setForegroundPen(2UB)
                        graphics.drawString(cursorChar, cursorX, textY)
                        // Restore background pen
                        graphics.setBackgroundPen(this.backgroundPen)
                        
                        // Draw text after cursor
                        if (this.cursorPosition + 1 < displayText.length()) {
                            var afterCursor = displayText.substringToEnd((this.cursorPosition + 1).toUInt())
                            graphics.setForegroundPen(this.textPen)
                            graphics.drawString(afterCursor, cursorX + charWidth, textY)
                        }
                    } else {
                        // Cursor is at end of text - draw cursor using width of "X", extended 1px above and below
                        var fontHeight = graphics.getCurrentFontSize().toShort()
                        var cursorWidth = graphics.calculateStringWidth("X").toShort()
                        graphics.setForegroundPen(this.cursorPen)
                        graphics.fillRect(cursorX, textY - 1S, cursorX + cursorWidth - 1S, textY + fontHeight)
                    }
                } else {
                    // Not focused - draw text normally
                    graphics.setForegroundPen(this.textPen)
                    graphics.drawString(displayText, textX, textY)
                }

                // Draw selection if focused and has selection
                if (this.focused && this.hasSelection()) {
                    // TODO: Calculate selection rectangle and draw it
                    // This would require character-by-character width calculation
                }
            }

//            graphics.resetClipArea()
        }

        override fun onMouseEvent(type: MouseEventType, button: MouseButton, x: Short, y: Short): Bool {
            if (this.contains(x, y)) {
                if (type == MouseEventType.down && button == MouseButton.left) {
                    this.setFocused(true)
                    
                    // Calculate cursor position from x coordinate
                    var textX = this.borderWidths.left + this.padding.left
                    var relativeX = x - textX
                    
                    if (relativeX <= 0S) {
                        // Click is before the text
                        this.setCursorPosition(0)
                    } else {
                        // Calculate which character position corresponds to the click
                        var displayText = this.text
                        if (this.passwordMode) {
                            var stars = ""
                            var i = 0
                            while (i < displayText.length()) {
                                stars = stars + "*"
                                i = i + 1
                            }
                            displayText = stars
                        }
                        
                        var window = this.getWindow()
                        if (window != null) {
                            var bestPosition = 0
                            var bestDistance = relativeX.toInt()
                            
                            // Check each position in the text
                            var pos = 0
                            while (pos <= displayText.length()) {
                                var width = 0S
                                if (pos > 0) {
                                    var substring = displayText.substring(0UI, pos.toUInt())
                                    width = window.calculateStringWidth(null, substring).toShort()
                                }
                                
                                var distance = (relativeX - width).toInt()
                                if (distance < 0) {
                                    distance = -distance
                                }
                                
                                if (distance < bestDistance) {
                                    bestDistance = distance
                                    bestPosition = pos
                                }
                                
                                pos = pos + 1
                            }
                            
                            this.setCursorPosition(bestPosition)
                        } else {
                            // Fallback if no graphics context
                            this.setCursorPosition(this.text.length())
                        }
                    }
                    
                    this.clearSelection()
                    return true
                }
            } else {
                if (type == MouseEventType.down) {
                    this.setFocused(false)
                }
            }
            return false
        }

        override fun onKeyboardEvent(type: KeyboardEventType, keyCode: UShort, keyChar: UShort): Bool {
            if (!this.focused || this.readOnly) {
                return false
            }

            if (type == KeyboardEventType.down) {
                // Handle arrow keys and navigation first (using keyCode)
                if (keyCode == 79US) { // Left arrow (AmigaOS raw key)
                    this.setCursorPosition(this.cursorPosition - 1)
                    this.clearSelection()
                    return true
                } else if (keyCode == 78US) { // Right arrow (AmigaOS raw key)
                    this.setCursorPosition(this.cursorPosition + 1)
                    this.clearSelection()
                    return true
                } else if (keyCode == 76US) { // Up arrow (could be used for Home)
                    this.setCursorPosition(0)
                    this.clearSelection()
                    return true
                } else if (keyCode == 77US) { // Down arrow (could be used for End)
                    this.setCursorPosition(this.text.length())
                    this.clearSelection()
                    return true
                }
                
                // Handle special character keys using keyChar
                if (keyChar == 8US) { // Backspace (ASCII)
                    this.deleteBackward()
                    return true
                } else if (keyChar == 127US) { // Delete (ASCII)
                    this.deleteForward()
                    return true
                } else if (keyChar == 9US) { // Tab
                    // Could handle tab here if needed
                    return false
                } else if (keyChar == 13US || keyChar == 10US) { // Return/Enter
                    // Could handle enter here if needed
                    return false
                } else if (keyChar >= 32US && keyChar <= 126US) { // Printable ASCII from keyChar
                    // Convert keyChar to string and use existing insertText method
                    var sb = new StringBuilder()
                    sb.addChar(keyChar)
                    var charString = sb.toString()
                    
                    this.insertText(charString)
                    return true
                }
                
                // Also check if keyChar has control character values for special keys
                if (keyChar == 37US) { // Left arrow (if passed as ASCII)
                    this.setCursorPosition(this.cursorPosition - 1)
                    this.clearSelection()
                    return true
                } else if (keyChar == 39US) { // Right arrow (if passed as ASCII)
                    this.setCursorPosition(this.cursorPosition + 1)
                    this.clearSelection()
                    return true
                } else if (keyChar == 36US) { // Home (if passed as ASCII)
                    this.setCursorPosition(0)
                    this.clearSelection()
                    return true
                } else if (keyChar == 35US) { // End (if passed as ASCII)
                    this.setCursorPosition(this.text.length())
                    this.clearSelection()
                    return true
                }
            }
            return false
        }
    }
}